---
title: 位运算各种
date: 2016-05-12 11:12:00
tags: BitManipulattion
categories:
  - 代码狗
  - 学习log
---

最近发现位运算在很多场合有很多运用啊。大概有以下几个方面:

- 涉及二进制及其2^n进制的运算
- 很少字段的struct class的改写例如棋盘记录和模式比较
- 逼格&效率比较高的小心机


# 几个运算符
|   符号  |   名称       | 含义  |
| :--------: |:------:| :------:|
| ``^``      | 按位亦或 | 同为0，异为1 |
| 竖线(打不了) | 按位或  |  有1则1，双0为0 |
| ``&``      |  按位与  |  有0则0，双为1 |
|``~``      |按位取反|变1为0，变0为1（包含符号位）|
|``<<``|按位左移（包括符号）|对应二进制每移一位乘二|
|``>>``|按位右移（包括符号）|对应二进制每移一位除二|
|``>>>`|按位无符号右移|对应二进制全指定的位数|

以上均是按位操作，要区分逻辑运算``&& ||``和位运算符``& |``

# 关于取反
普通的Integer char等按位操作都是直接按照它们的二进制补码操作，int直接使用该数字的补码，char则先按照ascii转换成二进制在进行操作。  
e.g.``char a = 'a'``a的ascii码十进制为097，二进制原码为1100001，这里注意，作为char，它在java中是一个<font color="red">无符号16位的整数</font>，所以补齐它的
二进制原码 补码 反码（非负数原码 补码 反码相同）
> 000000000 1100001

取反后的补码
> 111111111 0011110

取反后的反码
> 111111111 0011101

取反后的源码
> 100000000 1100010

十进制即为 **-98**。 
同理的，byte如果存储字符型也是按照先转成ascii码进行操作，即便是字符型的数字也一样。

```java
byte a = 2;
int b = ~a;//输出b为-3
byte c = '2';
int d = ~c;//输出d为-51 2的ascii为50(十进制) 32(十六进制)
```
# 关于亦或
亦或相当的特别同时阴森啊，有几个性质

- a^a = 0 也就是亦或自己为0，因为每位都是相同的。
- a^a^a = a^0 = 0^a  = a
- a^b = b^a 符合交换律
- (a^b)^c = a^(b^c) 符合结合律
- e = a^b^c^d <-> e^a = b^c^d <-> e^a^b= c^d <-> e^a^b^c=d

既然满足交换律结合律，则如果出现这么一种情况，
> [一个数组里除了一个数值出现一次，其他都出现了两次。找出这个数值。]
将这个数组全部亦或一遍，则出现两次的都可以按照交换律结合律化为0，

## 数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数
>思路：这就是上面实例的改进，因为知道了其他数字都出现了偶数次，全体亦或的结果就是``x=a^b`` 其中a b分别是所要找的这两个数。由于a b不同，则x必然不为零，也必然存在为1的位（可以取从右第一次出现1的位置）。同时由于是亦或操作，这个1必然是a和b相异造成的。这样，把这一位为1的分一组，这一位为0的分一组，出现偶数次的依然会被分到一组通过亦或自己消除。

```java
    //从右寻找补码中1第一次出现的位置
    public static int getFirst1(int num){
        int index = 0;
        while(index<32){
            if(((num&(1<<index))^(1<<index))==0)
                return index+1;
            else
                index++;
        }
        return -1;
    }

    //判断这个数这一位是否为1
    public static boolean is1AtPos(int num,int pos){    
        return ((num>>(pos-1))&1)==1;
    }

    //寻找这两个数
    public static int[] get2Num(int[] a){
        int [] find2Num = new int[2];
        //默认初始化0
        int rs = 0;
        for (int i : a) {
            rs ^= i;//亦或全体求x
        int pos=getFirst1(rs);//寻找第一个出现1的位
        for (int j : a) {
            if(is1AtPos(j,pos))//按这位是否位1分组
                find2Num[0] ^= j;
            else
                find2Num[1] ^= j;           
        }
        System.out.println(find2Num[0]+" "+find2Num[1]);
        return find2Num;
    }
```
## 使用位亦或(^)节约空间的数据交换

原理：a亦或b=c，b亦或a=c，也就是亦或满足交换律；位亦或的逆运算，也就是``(a^b)^b=a``等于它自己。所以，只需三个亦或运算即可交换数据。看代码。

```
    a ^= b;
    b ^= a;
    a ^= b;
```
## 使用亦或加密

中文配合亦或加密再加上其他的一些加密算法可以很好的掩护原文。

```
        char  a1='晚' ,  a2='上' ,  a3='来' ,  a4='我',  a5='家' ; 
        char secret='8' ; 
        a1=(char) (a1^secret); 
        a2=(char) (a2^secret); 
        a3=(char) (a3^secret); 
        a4=(char) (a4^secret); 
        a5=(char) (a5^secret); 
        System.out.println("密文:"+a1+a2+a3+a4+a5); 
        a1=(char) (a1^secret); 
        a2=(char) (a2^secret); 
        a3=(char) (a3^secret); 
        a4=(char) (a4^secret); 
        a5=(char) (a5^secret); 
        System.out.println("原文:"+a1+a2+a3+a4+a5); 
```
## 亦或判别IP地址是否相等
使用亦或在加上按位与的方式比==加&&的方式效率高。
```
    static int ipv6_addr_equal(int[] in6_addr_a1, int[] in6_addr_a2)
    {
    return (((in6_addr_a1[0] ^ in6_addr_a2[0]) |
        (in6_addr_a1[1] ^ in6_addr_a2[1]) |
        (in6_addr_a1[2] ^ in6_addr_a2[2]) |
        (in6_addr_a1[3] ^ in6_addr_a2[3])) == 0);
    }
```

# 关于按位与
按位与操作一般是与1配合 判断奇偶，或者判断某位是否为1；或保留下某位位数字(与位移结合)

```
a&1 == 0    偶数
a&1 == 1    奇数
```
# 关于按位与
按位或操作一般与0配合 
# 按位左右移
左右移本质上就是以bit为单元进行二进制的操作，而二进制左右移n位在十进制就意味着乘以2^n或除以2^n.按位操作可以大大提升效率
港真，很多面试都有求幂的题目。很棒，刷题狗就喜欢做这种题，然而第一次碰到这题我懵逼的采用了树。傻缺了。

将二进制数绕圈循环，取往左(右)第k个为头。很多题目里面有啊

```java
int a = a<<k | a >> (Integer.SIZE-k); //左数第k个当头
int b = b>>k | b >> (Integer.SIZE-k); //右数第k个当头
```
第k位置1

```java
    a|(1<<k);
```
第k位置0

```
    a&(~(1<<k));
```
取第k位的数值

```
    a>>k&1;
```
后k位为0，其余为1

```
    (~0)&(1<<(k+1));
```
后k位为1，其余为0

```
    ~((~0)<<k);
```

## 左右移应用-二分求幂

** <font color="red">Caution！这个思想很重要!</font>**  
> 思路：求a^b，如果b是一个2的整数幂，举个栗子，32，那可以进行这样的迭代，由于$32=2^5$,那么就可以这样求，

1. 第一次求 $a_1=a^2$  
2. 第二次求 $a_2=a^4=a^{2*2}={a_1}^2$  
3. 第三次求 $a_3=a^8=a^{4*2}={a_2}^2$  
4. 第四次求 $a_4=a^{16}=a^{8*2}={a_3}^2$
5. 第五次求 $a_5=a^{32}=a^{16*2}={a_4}^2$

如果是通过迭代幂的次数，需要32次才能达到，然而通过分治的方式，只需要5次就能解算32次幂。那如果不是2的整数幂次方呢，很好办，通过将该整数分解成各个2的整数次幂的和，例如求取a的23次方,又$23=16+4+2=1$，所以原式可化为$a^{2^4+2^2+2^1+2^0}$,通过二分的方式，变形为$$(a^{16})\cdot (a^4)\cdot (a^1)\cdot (a^0)$$.  
显然！上式就是二进制和十进制转换的过程，通过4+2+1=7次计算就可解出，而非单循环的23次。
其实，解算a的16次方中，即可用到$${a^4}^{2^2}$$,即计算a^的16次方只需用到2步，总共2+2+1=5次迭代就可计算完毕。
因而解决a^b次幂的步骤是  
- 将幂次化为2进制  
- 从低位遍历，为1则乘以当前幂次，为0则计算当前幂次，然后跳过，直接移至下一位  
- 当幂指数的二进制推到最高位  

```java
    public static long Power(int a, int n){
        long ans = 1;
        System.out.println("幂指数二进制："+Integer.toBinaryString(n));
        while (n > 0) {
            if ((n & 1)!=0) {//末位不为零
                ans *= a;
            } 
            a *= a;//计算当前幂次
            n >>= 1;//迭代每次推一位
        }
        return ans;
    }
```
递归版本可能更清晰

```java
    public static int power(int a,int n)  {  
        if(n==1) return a;  
        if(n&1)  
          return power(a,n-1) * a;  
        else  
        {  
            int t=power(a,n>>1);  
            return t*t;  
        }  
    }  
```