---
title: '树系列码集合[持更]'
date: 2016-05-03 23:06:28
tags:
---
本文持更树操作集合-码狗学习中
<!--more-->
# 二叉查找树转双链表（c++）
> 需求就是一个二叉树查找树 ，要转成按顺序排列的双向链表
> 
> 思路差不多就是：中序可以按顺序输出；左儿子指针指向相邻小的，右儿子指针指向相邻大的；相邻由中序控制,左右儿子改动的时候寄存在pre(前驱)和root(当前)下

**关键代码**

定义模版类及head pre指针
```c++
    template<class T>                  //模版结构体
    struct TreeNode
    {
        T data;                       //节点的内容
        TreeNode <T> *Lchild, *Rchild,*pParent; //节点的左子树和右子树
    //可选择参数的默认构造函数
    TreeNode(T nodeValue = T(), TreeNode<T> *leftNode = NULL, TreeNode<T> *rightNode = NULL, TreeNode<T> *parentNode = NULL)
    :data(nodeValue),Lchild(leftNode),Rchild(rightNode),pParent(parentNode){}
    };

    TreeNode<int> * pHead =NULL;//存放头指针
    TreeNode<int> * previous = NULL;//存放前驱
```
核心转换代码

```c++
    template<class T>
    void Tranverse(TreeNode<T> * root)//记前序
    {
        if (root){
            Tranverse(root->Lchild);//很明显的中序遍历阿！
            if (previous){
                if (!pHead){//这个if可以不写啊 只是为了记录头结点而已
                    pHead = previous;
                }
                previous->Rchild = root;//前驱的右指针指向root
                root->Lchild = previous;//root的左指针指向前驱
            }
            previous = root;//前驱跑到下一个更新
            Tranverse(root->Rchild);
        }
    }
```
调用代码,我才懒得写insert代码啊，rootNode从哪里来的我也不管啊

```c+
    Tranverse(rootNode);
    while (pHead != NULL){
        cout << pHead->data << endl;
        pHead = pHead->Rchild;
    }
```
代码见[这里](https://github.com/ovjaywang/TreeInvolved/tree/master/BSTree2DoubleLinkList)  

# 在二叉查找树里查找范围内数据(c++)
> 二叉查找树对于范围查找效率比普通线性查找效率高，Point仍旧是中序按序输出。
> 
> 思路：这次换一个c语言方式类typedef定义二叉树模版，以二叉按次序找到下限第一个，然后其后的数据与最大最小值比较，在范围内就输出。因此，在二叉查找树中序输出中中，加两个判断条件
> 1. 进入左子树需要根节点比最小值大  
> 2. 进入右子树需要根节点比最大值小

类模版定义

```c
typedef int KeyType;
typedef struct TreeNode
{
    KeyType key;          //关键字
    struct TreeNode * left;   //左孩子指针
    struct TreeNode * right;  //右孩子指针
    struct TreeNode * parent; //指向父节点指针
}TreeNode, *PNode;
```

关键代码 以范围搜索

```c
    set<KeyType> searchRange(KeyType min, KeyType max, set<KeyType> &vt, TreeNode *root){
        if (!root) return vt ;
        if (min < root->key)
            searchRange(min, max, vt,root->left);
        if (min <= root->key && max >= root->key){
            vt.insert(root->key);
        }
        if (max>root->key)
            searchRange(min, max, vt,root->right);
        return vt;
    }
```

调用代码

```c
    set<int> ss = set<int>();
    //很多地方都会把set带进函数迭代传递
    ss = searchRange(0, 3, ss, root);
    cout << "vv.size() "<<ss.size()<<endl<<"范围内包含节点有:"<<endl;
    for each (int item in ss)
    {
        cout << item<<" ";
    }
```
代码见[这里](https://github.com/ovjaywang/TreeInvolved/tree/master/FindInBSTree)

# 输出(平衡)二叉树所有和为某值的路径

>需求：一条路径就是从根到叶子所有节点，路径数就是叶子数。要输出所有满足路径上所有节点和为某值的路径。
> 
> 思路：为了保证效率，不能每次从头遍历到每个叶子才输出一次。
> 1. 使用栈压入根到当前节点的路径所有制，以便求和
> 2. 栈和超过值可以不继续寻找当前路径的儿子
> 3. 找一个儿子就在栈压入一个数值，跳回一个根就弹出一个儿子的值

当然，我很无聊，试一试平衡二叉(AVL).平衡二叉防止了直接建立查找二叉时候的随机，保证了时间复杂式始终在log(n).但建立AVL时候的插入删除代价也相对较大。

AVL模版类的声明，多了一个height（高度）属性。

```c++
    template <class T>
    class AVLTreeNode{
    public:
        T key;                // 关键字(键值)
        int height;         // 高度
        AVLTreeNode *left;    // 左孩子
        AVLTreeNode *right;    // 右孩子
        //构造函数
        AVLTreeNode(T value, AVLTreeNode *l, AVLTreeNode *r) :
            key(value), height(0), left(l), right(r) {}
    };
```

AVLtree类中包含了函数声明和一个``AVLTreeNode<T> *mRoot;``作为根节点；一个public的函数``void SearchPath(const T value);``给外部调用；一个private的函数``void SearchPath(AVLTreeNode<T>* root, T* seq, T top, T sumCount, const T value);``作为自迭代的函数，传入当前节点指针，当前线性表指针，栈顶指针(栈压入的数目)，当前和以及目标值。

关键代码，使用的是栈，但其实就是个顺序表，系统自动建立内存空间，每次进栈自增。
公有函数

```c++
    template<class T>
    void AVLTree<T>::SearchPath(const T value){
        T * seq = new int[0];
        T sumCount = 0;//当前累积值
        T top = 0;
        return SearchPath(mRoot, seq, top, sumCount, value);
    }
```

私有函数  

```c++
    //遍历次序无所谓的 反正要遍历所有叶子
    template<class T>
    void AVLTree<T>::SearchPath(AVLTreeNode<T>* root, T* seq, T top, T sumCount, const T value)//按值传递回溯不用恢复参数值和栈顶  
    {
        seq[top++] = root->key;//入栈
        sumCount += root->key;//累加和
        //if(sumCount > value) return;//当值为正数时可加上这句话
        if (root->left == NULL && root->right == NULL){//为叶子节点
            if (sumCount == value)
                for (int i = 0; i<top; i++)
                    cout << seq[i] << " ";
        }
        else{
            if (root->left)
                SearchPath(root->left, seq, top, sumCount, value);
            if (root->right)
                SearchPath(root->right, seq, top, sumCount, value);
        }
    }
```

调用代码  

```c++
    AVLTree<int>* tree = new AVLTree<int>();
    int const value = 16;//目标和
    tree->SearchPath(value);
```
代码见[这里](https://github.com/ovjaywang/TreeInvolved/tree/master/FindSumEqualNumInAVL)


